{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Hydrogen permeation","text":"<p>Simple numerical diffusion models in Python.</p> <p>This repository is a small Python package plus examples for solving the 1D hydrogen diffusion / permeation problem in a metal membrane.</p> <p>It started as a LaTeX note collection and gradually turned into runnable code. Now it\u2019s documented with MkDocs and focuses on practical use + minimal theory.</p> <p>The goal here is not to be exhaustive or perfectly general, but to provide:</p> <ul> <li>working numerical schemes,</li> <li>clear assumptions,</li> <li>and examples that are easy to modify.</li> </ul> <p>If you need a fast way to run a permeation model and understand what the code is doing, this is for you.</p>"},{"location":"#whats-inside","title":"What\u2019s inside","text":"<ul> <li> <p>1D diffusion equation for hydrogen in a flat membrane   (no traps, no bulk reactions \u2014 the baseline case)</p> </li> <li> <p>Finite-difference schemes</p> </li> <li>explicit stencils (for intuition)</li> <li> <p>implicit schemes (Backward Euler, Crank\u2013Nicolson\u2013style grids)</p> </li> <li> <p>Python implementations</p> </li> <li>NumPy / SciPy for arrays and sparse solvers</li> <li> <p>structured so you can swap parameters and boundary conditions easily</p> </li> <li> <p>Examples</p> </li> <li>how to run a simulation</li> <li>how to extract permeation flux</li> <li>how numerical choices affect stability and speed</li> </ul> <p>This is intentionally example-driven, not framework-heavy.</p>"},{"location":"#what-this-is-not","title":"What this is not","text":"<ul> <li>Not a polished simulation framework</li> <li>Not a benchmark against every solver under the sun</li> <li>Not a review article</li> </ul> <p>If you need traps, multiple species, or full thermo-kinetics \u2014 this code is meant to be a starting point, not the final word.</p>"},{"location":"#documentation-map","title":"Documentation map","text":"<ul> <li> <p>Diffusion equation   Governing PDE and boundary conditions used here</p> </li> <li> <p>Finite difference methods   Grid setup, stencils, and stability notes</p> </li> <li> <p>Equation cheat sheet   Stencils, coefficients, and \u03c3 definitions used in the code</p> </li> </ul>"},{"location":"#references","title":"References","text":"<p>This package does not attempt to reproduce or follow the full body of hydrogen transport theory and simulation developed over the last decades.</p> <p>Instead, it implements a minimal recombination\u2013diffusion model as a clean, transparent starting point \u2014 something that is easy to read, run, and modify.</p> <p>That said, it sits within a much broader historical and methodological context, which is worth being aware of: A bit of history. </p>"},{"location":"#why-mkdocs","title":"Why MkDocs","text":"<p>(and not LaTeX)</p> <p>LaTeX was great for derivations. MkDocs is better for:</p> <ul> <li>code + explanation living together,</li> <li>quick edits,</li> <li>examples that actually run.</li> </ul> <p>The math hasn\u2019t disappeared \u2014 it\u2019s just no longer pretending to be a paper.</p>"},{"location":"DECISIONS/","title":"Refactoring decisions and assumptions","text":""},{"location":"DECISIONS/#proposed-directory-tree","title":"Proposed directory tree","text":"<pre><code>PermeationFit/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 DECISIONS.md\n\u2502   \u251c\u2500\u2500 javascripts/\n\u2502   \u2502   \u2514\u2500\u2500 config.js\n\u2502   \u251c\u2500\u2500 theory/\n\u2502   \u2502   \u251c\u2500\u2500 diffusion.md\n\u2502   \u2502   \u2514\u2500\u2500 finite_methods.md\n\u2502   \u2514\u2500\u2500 reference/\n\u2502       \u2514\u2500\u2500 equations.md\n\u251c\u2500\u2500 figures/\n\u2502   \u2514\u2500\u2500 *.png\n\u251c\u2500\u2500 notebooks/\n\u2502   \u2514\u2500\u2500 *.ipynb\n\u251c\u2500\u2500 oldcode/\n\u2502   \u251c\u2500\u2500 diffusion.py\n\u2502   \u251c\u2500\u2500 pdp_wavefit.py\n\u2502   \u2514\u2500\u2500 pydiffuse.py\n\u251c\u2500\u2500 sections/          # original LaTeX (unchanged)\n\u2502   \u2514\u2500\u2500 *.tex, *.pdf\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 permeation/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 diffusion.py\n\u2502       \u251c\u2500\u2500 solvers.py\n\u2502       \u251c\u2500\u2500 materials.py\n\u2502       \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 summary.tex\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"DECISIONS/#package-layout","title":"Package layout","text":"<ul> <li>src/permeation/ \u2014 Single package, <code>src</code> layout (PEP 517/518 style). Name <code>permeation</code> matches the problem domain.</li> <li>diffusion.py \u2014 Public API: <code>BE</code>, <code>parameters</code> (re-exported from materials/solvers).</li> <li>solvers.py \u2014 Backward Euler implementation only. Logic taken from <code>oldcode/diffusion.py</code> (canonical version; <code>pdp_wavefit.py</code> had the same BE plus <code>tools</code> and wavefit).</li> <li>materials.py \u2014 Default <code>parameters()</code> dict (grid, physics constants, flags).</li> <li>utils.py \u2014 <code>chi_square(exp, calc)</code> for fitting; no external <code>tools</code> dependency.</li> </ul>"},{"location":"DECISIONS/#what-was-not-moved","title":"What was not moved","text":"<ul> <li>pdp_wavefit.py \u2014 <code>wavefit()</code>, <code>plot_result()</code>, and file I/O depend on external <code>tools</code> (paths, network drives, savitzky_golay, etc.). Left in <code>oldcode/</code>; notebooks or scripts can be updated later to use <code>permeation.BE</code> and <code>permeation.chi_square</code> with their own I/O.</li> <li>pydiffuse.py \u2014 Crank\u2013Nicolson <code>run()</code> and PDF/plotting depend on <code>tools</code> and different BC handling. Not merged into the package to avoid scope creep; can be ported later if needed.</li> <li>oldcode/ \u2014 Kept as-is for reference; no deletions.</li> </ul>"},{"location":"DECISIONS/#behaviour-and-compatibility","title":"Behaviour and compatibility","text":"<ul> <li>BE() \u2014 Signature accepts the same keys as before (Nx, Nt, T, D, L, ku, kd, ks, G, I, Uinit, PLOT, ncorrection, etc.). Extra keys (e.g. <code>Tend</code>, <code>saveU</code>) are absorbed by <code>**kwargs</code> and ignored. Return dict includes <code>fluxes</code> (DataFrame), <code>c</code>, <code>calctime</code>, and for compatibility <code>time</code> and <code>pdp</code>.</li> <li>Windows factor \u2014 The <code>ku</code>/<code>kd</code> \u00d7 2 correction on <code>os.name == \"nt\"</code> is preserved for TMAP7 agreement.</li> <li>Bug fix \u2014 The stray <code>u\"Instead of u**2...\"</code> string in the original was treated as code; it is now a comment (and the iterative correction loop is unchanged).</li> </ul>"},{"location":"DECISIONS/#documentation","title":"Documentation","text":"<ul> <li>MkDocs Material \u2014 <code>mkdocs.yml</code> and <code>docs/</code> with <code>index.md</code>, <code>theory/diffusion.md</code>, <code>theory/finite_methods.md</code>, <code>reference/equations.md</code>. LaTeX converted to Markdown with \\( \\) and [ ] for math (MathJax).</li> <li>Figures \u2014 Not copied; referenced from repo root <code>figures/</code> in README. MkDocs site does not embed them; links point to repo paths.</li> <li>summary.tex \u2014 Content folded into <code>docs/index.md</code> (abstract + intro). Subfiles <code>sections/*.tex</code> became the theory and reference pages.</li> </ul>"},{"location":"DECISIONS/#notebooks","title":"Notebooks","text":"<ul> <li>notebooks/ \u2014 Unchanged except one new cell in <code>RunDiffusion.ipynb</code>: <code>from permeation import BE, parameters</code> and <code>import numpy as np</code>. Assumes the package is installed (<code>pip install -e .</code>) from the repo root. No conversion of notebooks to library code.</li> </ul>"},{"location":"DECISIONS/#assumptions","title":"Assumptions","text":"<ul> <li>Python 3.8+.</li> <li>setuptools backend only; no PyPI/CI/tests added.</li> <li>Scientific results and numerical behaviour are preserved; only structure, packaging, and docs were changed.</li> </ul>"},{"location":"reference/equations/","title":"Stencil cheat sheet","text":"<p>Space and time indices are denoted \\(x\\) and \\(t\\) here.</p>"},{"location":"reference/equations/#definition-of-sigma","title":"Definition of \\(\\sigma\\)","text":"<p>For Crank\u2013Nicolson, the second derivative is approximated as the average of forward and backward Euler in time, giving:</p> \\[ \\frac{u_{x}^{t + 1} - u_{x}^{t}}{\\Delta t} = \\frac{D}{2 \\Delta x^2} \\left( (u_{x + 1}^{t + 1} - 2 u_{x}^{t + 1} + u_{x - 1}^{t + 1}) + (u_{x + 1}^{t} - 2 u_{x}^{t} + u_{x - 1}^{t}) \\right) \\] <p>So \\(\\sigma = \\frac{D\\Delta t}{2\\Delta x^2}\\).</p> <p>For explicit (forward Euler) stencils:</p> \\[ \\frac{u_{x}^{t + 1} - u_{x}^{t}}{\\Delta t} = \\frac{D}{\\Delta x^2} \\left(u_{x + 1}^{t} - 2 u_{x}^{t} + u_{x - 1}^{t}\\right) \\] <p>In that case \\(\\sigma = \\frac{D\\Delta t}{\\Delta x^2}\\).</p> <p>Below, \\(\\sigma = \\frac{D\\Delta t}{\\Delta x^2}\\) is used for all stencils.</p>"},{"location":"reference/equations/#stencils","title":"Stencils","text":"<p>Forward Euler (explicit):</p> \\[ U_{x}^{t+1} = \\sigma U_{x-1}^{t} + (1-2\\sigma)U_{x}^{t} + \\sigma U_{x+1}^{t} \\] <p>Backward Euler (implicit):</p> \\[ -\\sigma U_{x-1}^{t+1} + (1+2\\sigma)U_{x}^{t+1} - \\sigma U_{x+1}^{t+1} = U_{x}^{t} \\] <p>Crank\u2013Nicolson (implicit, second order in time), with \\(\\sigma = \\frac{D\\Delta t}{\\Delta x^2}\\):</p> \\[ -\\frac{\\sigma}{2} U_{x-1}^{t+1} + (1+\\sigma)U_{x}^{t+1} - \\frac{\\sigma}{2} U_{x+1}^{t+1} = \\frac{\\sigma}{2} U_{x-1}^{t} + (1-\\sigma)U_{x}^{t} + \\frac{\\sigma}{2} U_{x+1}^{t} \\]"},{"location":"reference/equations/#backward-euler-with-permeation-boundary-conditions","title":"Backward Euler with permeation boundary conditions","text":"\\[ -\\sigma U_{x-1}^{t+1} + (1+2\\sigma)U_{x}^{t+1} - \\sigma U_{x+1}^{t+1} = U_{x}^{t} \\] \\[ U_{0}^{t+1} = -\\frac{D}{2k_u\\Delta x} + \\frac{1}{2}\\sqrt{\\left(\\frac{D}{k_u\\Delta x}\\right)^2 + 4\\frac{D}{k_u\\Delta x}U_{1}^{t+1} + \\Gamma^{t+1}} \\] \\[ U_{L}^{t+1} = -\\frac{D}{2k_d\\Delta x} + \\frac{1}{2}\\sqrt{\\left(\\frac{D}{k_d\\Delta x}\\right)^2 + 4\\frac{D}{k_d\\Delta x}U_{L-1}^{t+1}} \\]"},{"location":"reference/history/","title":"\ud83e\udded Background &amp; context","text":""},{"location":"reference/history/#early-models","title":"\ud83e\uddea Early models","text":"<p>The basic recombination\u2013diffusion\u2013permeation picture originates from early work on atomic hydrogen interaction with metals, in particular:</p> <ul> <li> <p>Ali-Khan, I.; Dietz, K. J.; Weldebrock, F. G.; Wienhold, P., The rate of hydrogen release out of clean metallic surfaces. DOI: 10.1016/0022-3115(78)90167-8</p> </li> <li> <p>Pick, M. A.; Sonnenberg, K., A model for atomic hydrogen\u2013metal interactions\u2014application to recycling, recombination and permeation. DOI: 10.1016/0022-3115(85)90459-3</p> </li> </ul> <p>These works established the surface\u2013bulk coupling via recombination that is still commonly used today. This package uses only the simplest form of these ideas.</p>"},{"location":"reference/history/#formal-theory","title":"\ud83d\udcda Formal theory","text":"<p>A. A. Pisarev and his student E. D. Marenkov developed this framework much further, publishing multiple papers and textbooks that treat hydrogen transport in a systematic, physically detailed way.</p> <p>Their work is not followed directly here. It is referenced mainly for context and future reading, to show how far the topic extends beyond the simplified model implemented in this code.</p>"},{"location":"reference/history/#modern-checks","title":"\ud83d\udd0d Modern checks","text":"<p>More recent work revisits recombination coefficients and their consistent use in transport calculations, for example:</p> <ul> <li>Schmid, K.; Zibrov, M., On the use of recombination rate coefficients in hydrogen transport calculations. DOI: 10.1088/1741-4326/ac07b2</li> </ul> <p>Such papers are useful for understanding limitations and ambiguities of simplified boundary conditions, rather than as direct implementation guides.</p>"},{"location":"reference/history/#this-code","title":"\ud83e\udde9 This code","text":"<p>This is a tiny, intentionally simple codebase.</p> <p>That is a feature, not a limitation: - easy to understand, - easy to modify, - suitable for teaching, testing ideas, or quick estimates.</p> <p>For production-level simulations, established tools are usually a better choice:</p> <ul> <li>FESTIM \u2014 https://festim.readthedocs.io/en/latest/  </li> <li>TMAP8 \u2014 https://mooseframework.inl.gov/TMAP8/</li> </ul> <p>With these tools now open source, developing a custom Monte Carlo model is also much more approachable than it used to be.</p> <p>This package is best viewed as an entry point, not an endpoint \ud83d\udeaa</p>"},{"location":"theory/diffusion/","title":"Permeation equation","text":"<p>The general equation for hydrogen permeation through a membrane (one-dimensional case):</p> \\[ \\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} + f(u) \\] \\[ \\Gamma_{\\mathrm{in}}(t) + D\\frac{\\partial u}{\\partial x}\\bigg|_{x = 0} - k_{u}u^{2}(0,t) = 0 \\] \\[ -D\\frac{\\partial u}{\\partial x}\\bigg|_{x = L} - k_{d}u^{2}(L,t) = 0 \\] <p>Here \\(u\\) is the concentration, \\(t\\) is time, \\(x\\) is the coordinate, \\(D\\) is the diffusion coefficient, \\(k_u\\) and \\(k_d\\) are the hydrogen recombination coefficients on the upstream and downstream sides, and \\(f(u)\\) may represent the contribution of hydrogen traps. The term \\(\\Gamma_{\\mathrm{in}}(t)\\) is the incident atomic hydrogen flux.</p> <p>The matrix in the non-boundary points is the same as in the Crank\u2013Nicolson formulation; the boundary coefficients are determined by the above boundary conditions. At the left boundary:</p> \\[ \\Gamma_{\\mathrm{inc}}^n - k_u U_0^{n2} + D\\frac{U_1^n - U_0^n}{\\Delta x} = 0 \\] <p>At the right boundary:</p> \\[ k_d U_{J-1}^{n2} + D\\frac{U_{J-1}^n - U_{J-2}^n}{\\Delta x} = 0 \\] <p>Solving both quadratic equations for \\(U_0^n\\) and \\(U_{J-1}^n\\) gives the boundary values from the previous time layer:</p> \\[ U_0^{n+1} = -\\frac{D}{2k_u\\Delta x} + \\frac{1}{2} \\sqrt{\\left(\\frac{D}{k_u \\Delta x}\\right)^2 + \\frac{4DU_1^n}{k_u \\Delta x} + \\frac{4\\Gamma_{\\mathrm{inc}}^n}{k_u}} \\] \\[ U_{J-1}^{n+1} = -\\frac{D}{2k_d\\Delta x} + \\frac{1}{2} \\sqrt{\\left(\\frac{D}{k_d \\Delta x}\\right)^2 + \\frac{4DU_{J-2}^n}{k_d \\Delta x}} \\]"},{"location":"theory/finite_methods/","title":"Finite difference methods","text":"<p>This section is adapted from the numerical-mooc notebooks.</p>"},{"location":"theory/finite_methods/#the-cranknicolson-method","title":"The Crank\u2013Nicolson method","text":"<p>The Crank\u2013Nicolson method is a finite difference scheme for the numerical integration of the heat equation and related PDEs. It is often used for reaction\u2013diffusion systems in one space dimension:</p> \\[ \\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} + f(u), \\qquad \\frac{\\partial u}{\\partial x}\\bigg|_{x = 0, L} = 0 \\] <p>Here \\(u\\) is the concentration, \\(x\\) is space, \\(D\\) is the diffusion coefficient, \\(f\\) is the reaction term, and \\(L\\) is the length of the domain. The boundary conditions are Neumann (zero flux at the boundaries).</p>"},{"location":"theory/finite_methods/#grid-and-notation","title":"Grid and notation","text":"<p>Time and space are discretised as:</p> \\[ t_n = n \\Delta t, \\quad n = 0, \\ldots, N-1 \\] \\[ x_j = j \\Delta x, \\quad j = 0, \\ldots, J-1 \\] <p>with \\(\\Delta t = T/N\\) and \\(\\Delta x = L/J\\). We write \\(U_j^n = U(j\\Delta x, n\\Delta t)\\) and define \\(\\sigma = \\frac{D \\Delta t}{2 \\Delta x^2}\\). The Crank\u2013Nicolson scheme for the reaction\u2013diffusion equation is:</p> \\[ -\\sigma U_{j-1}^{n+1} + (1+2\\sigma) U_j^{n+1} -\\sigma U_{j+1}^{n+1} = \\sigma U_{j-1}^n + (1-2\\sigma) U_j^n + \\sigma U_{j+1}^n + \\Delta t f(U_j^n) \\] <p>for \\(j = 1,\\ldots,J-2\\). At the boundaries \\(j=0\\) and \\(j=J-1\\) the values \\(U_{-1}^n\\) and \\(U_J^n\\) are defined by the Neumann conditions (backward difference at \\(j=0\\), forward at \\(j=J-1\\)):</p> \\[ \\frac{U_1^n - U_0^n}{\\Delta x} = 0, \\qquad \\frac{U_J^n - U_{J-1}^n}{\\Delta x} = 0 \\] <p>so \\(U_0^n = U_1^n\\) and \\(U_{J-1}^n = U_J^n\\). In vector form \\(\\mathbf{U}^n = (U_0^n, \\ldots, U_{J-1}^n)^T\\) the system is:</p> \\[ A \\mathbf{U}^{n+1} = B \\mathbf{U}^n + \\mathbf{f}^n \\] <p>and</p> \\[ \\mathbf{U}^{n+1} = A^{-1} \\left( B \\mathbf{U}^n + \\mathbf{f}^n \\right) \\] <p>Matrix \\(A\\) is constant and can be factorised once; \\(B \\mathbf{U}^n + \\mathbf{f}^n\\) is updated each time step.</p>"}]}