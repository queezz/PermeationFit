{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Hydrogen permeation","text":"<p>Simple numerical diffusion models in Python.</p> <p>This repository is a small Python package plus examples for solving the 1D hydrogen diffusion / permeation problem in a metal membrane.</p> <p>It started as a LaTeX note collection and gradually turned into runnable code. Now it\u2019s documented with MkDocs and focuses on practical use + minimal theory.</p> <p>The goal here is not to be exhaustive or perfectly general, but to provide:</p> <ul> <li>working numerical schemes,</li> <li>clear assumptions,</li> <li>and examples that are easy to modify.</li> </ul> <p>If you need a fast way to run a permeation model and understand what the code is doing, this is for you.</p>"},{"location":"#whats-inside","title":"What\u2019s inside","text":"<ul> <li> <p>1D diffusion equation for hydrogen in a flat membrane   (no traps, no bulk reactions \u2014 the baseline case)</p> </li> <li> <p>Finite-difference schemes</p> </li> <li>explicit stencils (for intuition)</li> <li> <p>implicit schemes (Backward Euler, Crank\u2013Nicolson\u2013style grids)</p> </li> <li> <p>Python implementations</p> </li> <li>NumPy / SciPy for arrays and sparse solvers</li> <li> <p>structured so you can swap parameters and boundary conditions easily</p> </li> <li> <p>Examples</p> </li> <li>how to run a simulation</li> <li>how to extract permeation flux</li> <li>how numerical choices affect stability and speed</li> </ul> <p>This is intentionally example-driven, not framework-heavy.</p>"},{"location":"#what-this-is-not","title":"What this is not","text":"<ul> <li>Not a polished simulation framework</li> <li>Not a benchmark against every solver under the sun</li> <li>Not a review article</li> </ul> <p>If you need traps, multiple species, or full thermo-kinetics \u2014 this code is meant to be a starting point, not the final word.</p>"},{"location":"#documentation-map","title":"Documentation map","text":"<ul> <li> <p>Diffusion equation   Governing PDE and boundary conditions used here</p> </li> <li> <p>Finite difference methods   Grid setup, stencils, and stability notes</p> </li> <li> <p>Equation cheat sheet   Stencils, coefficients, and \u03c3 definitions used in the code</p> </li> </ul>"},{"location":"#references","title":"References","text":"<p>This package does not attempt to reproduce or follow the full body of hydrogen transport theory and simulation developed over the last decades.</p> <p>Instead, it implements a minimal recombination\u2013diffusion model as a clean, transparent starting point \u2014 something that is easy to read, run, and modify.</p> <p>That said, it sits within a much broader historical and methodological context, which is worth being aware of: A bit of history. </p>"},{"location":"#why-mkdocs","title":"Why MkDocs","text":"<p>(and not LaTeX)</p> <p>LaTeX was great for derivations. MkDocs is better for:</p> <ul> <li>code + explanation living together,</li> <li>quick edits,</li> <li>examples that actually run.</li> </ul> <p>The math hasn\u2019t disappeared \u2014 it\u2019s just no longer pretending to be a paper.</p>"},{"location":"DECISIONS/","title":"Refactoring decisions and assumptions","text":""},{"location":"DECISIONS/#proposed-directory-tree","title":"Proposed directory tree","text":"<pre><code>PermeationFit/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 DECISIONS.md\n\u2502   \u251c\u2500\u2500 javascripts/\n\u2502   \u2502   \u2514\u2500\u2500 config.js\n\u2502   \u251c\u2500\u2500 theory/\n\u2502   \u2502   \u251c\u2500\u2500 diffusion.md\n\u2502   \u2502   \u2514\u2500\u2500 finite_methods.md\n\u2502   \u2514\u2500\u2500 reference/\n\u2502       \u2514\u2500\u2500 equations.md\n\u251c\u2500\u2500 figures/\n\u2502   \u2514\u2500\u2500 *.png\n\u251c\u2500\u2500 notebooks/\n\u2502   \u2514\u2500\u2500 *.ipynb\n\u251c\u2500\u2500 oldcode/\n\u2502   \u251c\u2500\u2500 diffusion.py\n\u2502   \u251c\u2500\u2500 pdp_wavefit.py\n\u2502   \u2514\u2500\u2500 pydiffuse.py\n\u251c\u2500\u2500 sections/          # original LaTeX (unchanged)\n\u2502   \u2514\u2500\u2500 *.tex, *.pdf\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 permeation/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 diffusion.py\n\u2502       \u251c\u2500\u2500 backward_euler.py\n\u2502       \u251c\u2500\u2500 materials.py\n\u2502       \u2514\u2500\u2500 utils.py\n\u251c\u2500\u2500 summary.tex\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"DECISIONS/#package-layout","title":"Package layout","text":"<ul> <li>src/permeation/ \u2014 Single package, <code>src</code> layout (PEP 517/518 style). Name <code>permeation</code> matches the problem domain.</li> <li>diffusion.py \u2014 Public API: <code>BE</code>, <code>parameters</code> (re-exported from materials/backward_euler).</li> <li>backward_euler.py \u2014 Backward Euler implementation only. Logic taken from <code>oldcode/diffusion.py</code> (canonical version; <code>pdp_wavefit.py</code> had the same BE plus <code>tools</code> and wavefit).</li> <li>materials.py \u2014 Default <code>parameters()</code> dict (grid, physics constants, flags).</li> <li>utils.py \u2014 <code>chi_square(exp, calc)</code> for fitting; no external <code>tools</code> dependency.</li> </ul>"},{"location":"DECISIONS/#what-was-not-moved","title":"What was not moved","text":"<ul> <li>pdp_wavefit.py \u2014 <code>wavefit()</code>, <code>plot_result()</code>, and file I/O depend on external <code>tools</code> (paths, network drives, savitzky_golay, etc.). Left in <code>oldcode/</code>; notebooks or scripts can be updated later to use <code>permeation.BE</code> and <code>permeation.chi_square</code> with their own I/O.</li> <li>pydiffuse.py \u2014 Crank\u2013Nicolson <code>run()</code> and PDF/plotting depend on <code>tools</code> and different BC handling. Not merged into the package to avoid scope creep; can be ported later if needed.</li> <li>oldcode/ \u2014 Kept as-is for reference; no deletions.</li> </ul>"},{"location":"DECISIONS/#behaviour-and-compatibility","title":"Behaviour and compatibility","text":"<ul> <li>BE() \u2014 Signature accepts the same keys as before (Nx, Nt, T, D, L, ku, kd, ks, G, I, Uinit, PLOT, ncorrection, etc.). Extra keys (e.g. <code>Tend</code>, <code>saveU</code>) are absorbed by <code>**kwargs</code> and ignored. Return dict includes <code>fluxes</code> (DataFrame), <code>c</code>, <code>calctime</code>, and for compatibility <code>time</code> and <code>pdp</code>.</li> <li>Windows factor \u2014 The <code>ku</code>/<code>kd</code> \u00d7 2 correction on <code>os.name == \"nt\"</code> is preserved for TMAP7 agreement.</li> <li>Bug fix \u2014 The stray <code>u\"Instead of u**2...\"</code> string in the original was treated as code; it is now a comment (and the iterative correction loop is unchanged).</li> </ul>"},{"location":"DECISIONS/#documentation","title":"Documentation","text":"<ul> <li>MkDocs Material \u2014 <code>mkdocs.yml</code> and <code>docs/</code> with <code>index.md</code>, <code>theory/diffusion.md</code>, <code>theory/finite_methods.md</code>, <code>reference/equations.md</code>. LaTeX converted to Markdown with \\( \\) and [ ] for math (MathJax).</li> <li>Figures \u2014 Not copied; referenced from repo root <code>figures/</code> in README. MkDocs site does not embed them; links point to repo paths.</li> <li>summary.tex \u2014 Content folded into <code>docs/index.md</code> (abstract + intro). Subfiles <code>sections/*.tex</code> became the theory and reference pages.</li> </ul>"},{"location":"DECISIONS/#notebooks","title":"Notebooks","text":"<ul> <li>notebooks/ \u2014 Unchanged except one new cell in <code>RunDiffusion.ipynb</code>: <code>from permeation import BE, parameters</code> and <code>import numpy as np</code>. Assumes the package is installed (<code>pip install -e .</code>) from the repo root. No conversion of notebooks to library code.</li> </ul>"},{"location":"DECISIONS/#assumptions","title":"Assumptions","text":"<ul> <li>Python 3.8+.</li> <li>setuptools backend only; no PyPI/CI/tests added.</li> <li>Scientific results and numerical behaviour are preserved; only structure, packaging, and docs were changed.</li> </ul>"},{"location":"package-map/","title":"Permeation package map","text":"<p>High-level map of the refactored <code>permeation</code> package: what lives where, how data flows, and why it\u2019s structured this way. For re-entering the codebase, not for API reference.</p>"},{"location":"package-map/#package-layout-by-role","title":"Package layout (by role)","text":"<pre><code>src/permeation/\n\u251c\u2500\u2500 physics/          # Forward model: PDE, parameters, G(t) shapes\n\u251c\u2500\u2500 inverse/          # Inverse problem: fit G(t) from measured pdp\n\u251c\u2500\u2500 viz/               # Plotting from result dicts only\n\u251c\u2500\u2500 utils.py           # Fitting metric (chi_square)\n\u2514\u2500\u2500 __init__.py        # Re-exports public API\n</code></pre> <p>Group by role: physics = \u201cgiven G(t), what is pdp?\u201d; inverse = \u201cgiven pdp, what is G(t)?\u201d; viz = \u201cdraw it\u201d; utils = shared helpers.</p>"},{"location":"package-map/#1-physics-physics","title":"1. Physics (<code>physics/</code>)","text":"<p>Problem: Solve 1D hydrogen diffusion through a membrane with recombination BCs. Given incident flux G(t), produce concentration and downstream flux (pdp).</p> <p>Owns:</p> <ul> <li>Backward Euler time integration and spatial discretisation (<code>backward_euler.py</code>).</li> <li>Parameter container and default grid/constants (<code>materials.py</code>).</li> <li>G(t) generators: constant, step, multi-step, refinement helpers (<code>materials.py</code>).</li> <li>Public API: <code>BE(parameters, **kwargs)</code> and <code>Parameters</code> (<code>diffusion.py</code> re-exports).</li> </ul> <p>Does not: Fit anything, read files, or know about \u201cmeasurement\u201d vs \u201cmodel\u201d grids. No inverse logic.</p> <p>Called by: Inverse fit (calls <code>BE</code> and materials helpers). Users call <code>BE</code> directly for forward runs.</p> <p>Design: Physics is a pure function of parameters; no global state. <code>BE</code> returns a dict (time, x, c, fluxes, pdp, \u2026). G is passed in via parameters or overrides.</p>"},{"location":"package-map/#2-inverse-inverse","title":"2. Inverse (<code>inverse/</code>)","text":"<p>Problem: Recover step values of G(t) from measured downstream pressure (pdp). Least-squares with optional L2 and total-variation regularization.</p> <p>Owns:</p> <ul> <li>Mapping step values + step starts \u2192 G(t) \u2192 BE run \u2192 pdp on model grid (<code>inverse_fit.simulate_from_step_vals</code>).</li> <li>Interpolation of model pdp onto measurement grid (<code>interp_to_meas_grid</code>).</li> <li>Single-level fit (<code>fit_G_steps</code>) and multi-level zoom fit (<code>fit_G_steps_zoom</code>).</li> <li>Adaptive bin refinement (<code>fit_with_adaptive_bins</code>, <code>refine_bins_adaptive</code>).</li> <li>Workflow class that holds data + params and runs zoom fit (<code>workflow.InverseFitWorkflow</code>).</li> </ul> <p>Does not: Implement the PDE (delegates to <code>physics.BE</code>). Does not own plotting (delegates to <code>viz</code>). Does not define Parameters (uses <code>physics.Parameters</code>).</p> <p>Called by: Notebooks/scripts; workflow is the main entry for \u201cload data \u2192 fit \u2192 plot\u201d. Low-level routines are used by workflow or for custom pipelines.</p> <p>State/history:</p> <ul> <li>Zoom result (<code>fit_G_steps_zoom</code> return value): <code>history</code> = one dict per zoom level (tstart, x_hat, pdp_hat, G_hat, cost, \u2026). Optional <code>states</code> = every optimizer iteration (level, iter, x, cost) when <code>save_states=True</code>.</li> <li>Workflow: Holds <code>t_meas</code>, <code>pdp_meas</code>, <code>base_params</code>, optional truth data; after <code>fit()</code>, stores the zoom result in <code>_result</code> and exposes it via <code>.result</code>.</li> </ul> <p>Design: Workflows are separated from solvers. <code>InverseFitWorkflow</code> is a thin wrapper: it keeps data and params, calls <code>fit_G_steps_zoom</code>, and delegates plotting to <code>viz</code>. All fit logic lives in <code>inverse_fit</code>; the workflow does not contain physics or solver code.</p>"},{"location":"package-map/#3-visualization-viz","title":"3. Visualization (<code>viz/</code>)","text":"<p>Problem: Produce figures from solver or inverse results. No physics, no fitting.</p> <p>Owns:</p> <ul> <li>Plots that consume solver output: profiles, fluxes, concentration 3D, summary (<code>plotting.py</code>).</li> <li>Plots that consume zoom result: inverse summary (measured vs fitted pdp + G), zoom frame (one level), convergence history (cost vs level), export of zoom-state frames (<code>plotting.py</code>).</li> <li>Plot of G(t) and data (optionally with truth) for workflow before/after fit (<code>plot_G</code>).</li> </ul> <p>Does not: Call the solver or the inverse. No physics constants or PDE logic. Operates only on dicts (e.g. <code>result</code> from <code>BE</code>, <code>zoom</code> from <code>fit_G_steps_zoom</code>).</p> <p>Called by: Workflow\u2019s <code>plot()</code> and <code>export_frames()</code> (which call into <code>viz</code>); users can also call plotting functions directly with a result dict.</p> <p>Design: Visualization is decoupled: it takes data in, draws it. Physics is not embedded in plotting\u2014no D, ks, or grid logic in <code>viz</code>; all of that lives in physics/inverse. Plotting is \u201cresult in \u2192 figure out\u201d.</p>"},{"location":"package-map/#4-utils-utilspy","title":"4. Utils (<code>utils.py</code>)","text":"<p>Owns: <code>chi_square(exp, calc)</code> \u2014 normalised sum of squared differences (scale by max(exp)). Used as a fitting cost when comparing calculated to experimental pdp.</p> <p>Does not: Run solver or inverse; no I/O.</p>"},{"location":"package-map/#data-flow-conceptual","title":"Data flow (conceptual)","text":"<pre><code>Experimental data (t_meas, pdp_meas)\n         \u2502\n         \u25bc\n   InverseFitWorkflow  (holds data + base_params)\n         \u2502\n         \u251c\u2500\u2500\u25ba fit() \u2500\u2500\u25ba fit_G_steps_zoom()\n         \u2502                    \u2502\n         \u2502                    \u251c\u2500\u2500\u25ba multi_step_G(steps) + BE(base_params)  [physics]\n         \u2502                    \u251c\u2500\u2500\u25ba interp_to_meas_grid(model_pdp, t_meas)\n         \u2502                    \u2514\u2500\u2500\u25ba least_squares(residual, x0, \u2026)  [per level]\n         \u2502\n         \u2502              \u25c4\u2500\u2500 zoom result dict (history, states?, tstart, x_hat)\n         \u2502\n         \u251c\u2500\u2500\u25ba .result  (stored for later)\n         \u2502\n         \u2514\u2500\u2500\u25ba plot(kind) / export_frames()\n                    \u2502\n                    \u2514\u2500\u2500\u25ba viz.plot_* (zoom, t_meas, pdp_meas, \u2026)  \u2192  figure/files\n</code></pre> <p>Typical path: Load or synthesize (t_meas, pdp_meas) and base_params \u2192 build workflow \u2192 <code>fit(n_levels, ...)</code> \u2192 zoom result is stored in workflow \u2192 <code>plot(\"summary\")</code> or <code>plot(\"convergence\")</code> or <code>export_frames()</code> use that result. Forward-only use: build <code>Parameters</code>, set G via materials helpers, call <code>BE(params)</code> \u2192 pass result dict to <code>plot_profiles</code>, <code>plot_fluxes</code>, etc.</p>"},{"location":"package-map/#where-statehistory-lives","title":"Where state/history lives","text":"<ul> <li>Zoom fit: <code>fit_G_steps_zoom</code> returns a dict with <code>history</code> (per-level results) and optionally <code>states</code> (per-iteration when <code>save_states=True</code>). Workflow keeps this in <code>_result</code> after <code>fit()</code>.</li> <li>Adaptive fit: <code>fit_with_adaptive_bins</code> returns a dict with its own <code>history</code> (edges/x/scores per refinement). No workflow wrapper; caller holds the result.</li> <li>Solver: <code>BE</code> returns a single result dict (no accumulation across calls). Concentration history is inside that dict (e.g. <code>c</code>).</li> </ul>"},{"location":"package-map/#design-decisions-why-its-like-this","title":"Design decisions (why it\u2019s like this)","text":"<ul> <li>Workflows vs solvers: The workflow holds data and orchestration; the solver is \u201crun BE with these params\u201d. Fit algorithms live in <code>inverse_fit</code>; the workflow just calls them and stores the result. Easier to test solvers and fits in isolation and to reuse fit logic without the workflow.</li> <li>Viz decoupled: Plotting only sees result dicts. You can change how results are produced (e.g. different optimizer) without touching viz; you can swap viz (e.g. different backend) without touching physics or inverse.</li> <li>Physics not in plotting: All PDE and parameter knowledge stays in <code>physics/</code>. Viz never imports BE or Parameters. Avoids circular deps and keeps \u201cwhat to draw\u201d separate from \u201chow it was computed\u201d.</li> <li>Single package, src layout: One namespace (<code>permeation</code>), installable with <code>pip install -e .</code>. <code>docs/DECISIONS.md</code> records what was left in <code>oldcode/</code> (e.g. wavefit, file I/O) and why.</li> </ul> <p>This page is navigation and architecture only. For API details see the code and docstrings; for theory see the Theory and References sections.</p>"},{"location":"reference/equations/","title":"Stencil cheat sheet","text":"<p>Space and time indices are denoted \\(x\\) and \\(t\\) here.</p>"},{"location":"reference/equations/#definition-of-sigma","title":"Definition of \\(\\sigma\\)","text":"<p>For Crank\u2013Nicolson, the second derivative is approximated as the average of forward and backward Euler in time, giving:</p> \\[ \\frac{u_{x}^{t + 1} - u_{x}^{t}}{\\Delta t} = \\frac{D}{2 \\Delta x^2} \\left( (u_{x + 1}^{t + 1} - 2 u_{x}^{t + 1} + u_{x - 1}^{t + 1}) + (u_{x + 1}^{t} - 2 u_{x}^{t} + u_{x - 1}^{t}) \\right) \\] <p>So \\(\\sigma = \\frac{D\\Delta t}{2\\Delta x^2}\\).</p> <p>For explicit (forward Euler) stencils:</p> \\[ \\frac{u_{x}^{t + 1} - u_{x}^{t}}{\\Delta t} = \\frac{D}{\\Delta x^2} \\left(u_{x + 1}^{t} - 2 u_{x}^{t} + u_{x - 1}^{t}\\right) \\] <p>In that case \\(\\sigma = \\frac{D\\Delta t}{\\Delta x^2}\\).</p> <p>Below, \\(\\sigma = \\frac{D\\Delta t}{\\Delta x^2}\\) is used for all stencils.</p>"},{"location":"reference/equations/#stencils","title":"Stencils","text":"<p>Forward Euler (explicit):</p> \\[ U_{x}^{t+1} = \\sigma U_{x-1}^{t} + (1-2\\sigma)U_{x}^{t} + \\sigma U_{x+1}^{t} \\] <p>Backward Euler (implicit):</p> \\[ -\\sigma U_{x-1}^{t+1} + (1+2\\sigma)U_{x}^{t+1} - \\sigma U_{x+1}^{t+1} = U_{x}^{t} \\] <p>Crank\u2013Nicolson (implicit, second order in time), with \\(\\sigma = \\frac{D\\Delta t}{\\Delta x^2}\\):</p> \\[ -\\frac{\\sigma}{2} U_{x-1}^{t+1} + (1+\\sigma)U_{x}^{t+1} - \\frac{\\sigma}{2} U_{x+1}^{t+1} = \\frac{\\sigma}{2} U_{x-1}^{t} + (1-\\sigma)U_{x}^{t} + \\frac{\\sigma}{2} U_{x+1}^{t} \\]"},{"location":"reference/equations/#backward-euler-with-permeation-boundary-conditions","title":"Backward Euler with permeation boundary conditions","text":"\\[ -\\sigma U_{x-1}^{t+1} + (1+2\\sigma)U_{x}^{t+1} - \\sigma U_{x+1}^{t+1} = U_{x}^{t} \\] \\[ U_{0}^{t+1} = -\\frac{D}{2k_u\\Delta x} + \\frac{1}{2}\\sqrt{\\left(\\frac{D}{k_u\\Delta x}\\right)^2 + 4\\frac{D}{k_u\\Delta x}U_{1}^{t+1} + \\Gamma^{t+1}} \\] \\[ U_{L}^{t+1} = -\\frac{D}{2k_d\\Delta x} + \\frac{1}{2}\\sqrt{\\left(\\frac{D}{k_d\\Delta x}\\right)^2 + 4\\frac{D}{k_d\\Delta x}U_{L-1}^{t+1}} \\]"},{"location":"reference/history/","title":"\ud83e\udded Background &amp; context","text":""},{"location":"reference/history/#early-models","title":"\ud83e\uddea Early models","text":"<p>The basic recombination\u2013diffusion\u2013permeation picture originates from early work on atomic hydrogen interaction with metals, in particular:</p> <ul> <li> <p>Ali-Khan, I.; Dietz, K. J.; Weldebrock, F. G.; Wienhold, P., The rate of hydrogen release out of clean metallic surfaces. DOI: 10.1016/0022-3115(78)90167-8</p> </li> <li> <p>Pick, M. A.; Sonnenberg, K., A model for atomic hydrogen\u2013metal interactions\u2014application to recycling, recombination and permeation. DOI: 10.1016/0022-3115(85)90459-3</p> </li> </ul> <p>These works established the surface\u2013bulk coupling via recombination that is still commonly used today. This package uses only the simplest form of these ideas.</p>"},{"location":"reference/history/#formal-theory","title":"\ud83d\udcda Formal theory","text":"<p>A. A. Pisarev and his student E. D. Marenkov developed this framework much further, publishing multiple papers and textbooks that treat hydrogen transport in a systematic, physically detailed way.</p> <p>Their work is not followed directly here. It is referenced mainly for context and future reading, to show how far the topic extends beyond the simplified model implemented in this code.</p>"},{"location":"reference/history/#modern-checks","title":"\ud83d\udd0d Modern checks","text":"<p>More recent work revisits recombination coefficients and their consistent use in transport calculations, for example:</p> <ul> <li>Schmid, K.; Zibrov, M., On the use of recombination rate coefficients in hydrogen transport calculations. DOI: 10.1088/1741-4326/ac07b2</li> </ul> <p>Such papers are useful for understanding limitations and ambiguities of simplified boundary conditions, rather than as direct implementation guides.</p>"},{"location":"reference/history/#this-code","title":"\ud83e\udde9 This code","text":"<p>This is a tiny, intentionally simple codebase.</p> <p>That is a feature, not a limitation: - easy to understand, - easy to modify, - suitable for teaching, testing ideas, or quick estimates.</p> <p>For production-level simulations, established tools are usually a better choice:</p> <ul> <li>FESTIM</li> <li>TMAP8</li> </ul> <p>With these tools now open source, developing a custom Monte Carlo model is also much more approachable than it used to be.</p> <p>This package is best viewed as an entry point, not an endpoint \ud83d\udeaa</p>"},{"location":"reference/notation/","title":"Numerical Diffusion \u2014 Notation &amp; Vocabulary","text":"<p>This page collects the basic symbols and operators used in the numerical solution of the diffusion equation, mainly in finite-difference form.</p>"},{"location":"reference/notation/#symbols","title":"Symbols","text":""},{"location":"reference/notation/#un","title":"\\( u^n \\)","text":"<p>Discrete solution vector at time step \\( n \\).</p> <p>Represents the value of the field (e.g. temperature, concentration, density) at all spatial grid points at time \\( t = n\\,\\Delta t \\).</p>"},{"location":"reference/notation/#delta-t","title":"\\( \\Delta t \\)","text":"<p>Time step size.</p> <p>Controls the temporal resolution of the simulation.</p>"},{"location":"reference/notation/#d","title":"\\( D \\)","text":"<p>Diffusion coefficient.</p> <p>May be a scalar (constant diffusion) or a function of space, time, or state.</p>"},{"location":"reference/notation/#operators-and-matrices","title":"Operators and Matrices","text":""},{"location":"reference/notation/#i-identity-matrix","title":"\\( I \\) \u2014 Identity matrix","text":"<p>Identity operator in discrete space.</p> <p>Acts as:</p> \\[ I\\,u = u \\] <p>In matrix form, \\( I \\) has ones on the diagonal and zeros elsewhere. It appears when time-derivative terms are written in operator form.</p>"},{"location":"reference/notation/#l-discrete-laplacian","title":"\\( L \\) \u2014 Discrete Laplacian","text":"<p>Matrix representation of the spatial Laplacian operator \\( \\nabla^2 \\).</p> <p>Obtained by discretising second spatial derivatives using finite differences (or finite volumes / finite elements).</p> <p>In 1D (uniform grid), \\( L \\) is tridiagonal.</p>"},{"location":"reference/notation/#time-integration","title":"Time Integration","text":""},{"location":"reference/notation/#backward-euler-implicit","title":"Backward Euler (implicit)","text":"<p>Time discretisation:</p> \\[ \\frac{u^{n+1} - u^n}{\\Delta t} = D\\,L\\,u^{n+1} \\] <p>Leads to the linear system:</p> \\[ \\left( I - \\Delta t\\,D\\,L \\right) u^{n+1} = u^n \\] <p>Properties: - Fully implicit - First order in time - Unconditionally stable for diffusion</p>"},{"location":"reference/notation/#derived-parameters","title":"Derived Parameters","text":""},{"location":"reference/notation/#r-dfracddelta-tdelta-x2","title":"\\( r = \\dfrac{D\\,\\Delta t}{\\Delta x^2} \\)","text":"<p>Dimensionless diffusion number.</p> <p>Appears naturally in finite-difference discretisations of the Laplacian.</p>"},{"location":"reference/notation/#notes","title":"Notes","text":"<ul> <li>Bold symbols typically represent vectors or matrices.</li> <li>Operators become matrices after spatial discretisation.</li> <li>In finite-element formulations, \\( I \\) is replaced by a mass matrix.</li> </ul>"},{"location":"theory/backward-euler/","title":"Backward Euler diffusion solver (BE)","text":"<p>This page documents the numerical method used in the Backward Euler (BE) permeation solver implemented in this project. It serves as a reference anchor for the solver design, terminology, and implementation choices.</p>"},{"location":"theory/backward-euler/#backward-euler-stencil","title":"Backward Euler stencil","text":"<p>Consider the 1D diffusion equation</p> \\[ \\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2}. \\] <p>Using Backward Euler in time and second-order central differences in space, we write</p> \\[ \\frac{u_j^{n+1} - u_j^n}{\\Delta t} = D \\, \\frac{u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}}{\\Delta x^2}. \\] <p>Rearranging,</p> \\[ -\\alpha\\, u_{j-1}^{n+1} + (1 + 2\\alpha)\\, u_j^{n+1} - \\alpha\\, u_{j+1}^{n+1} = u_j^n, \\qquad \\alpha = D\\,\\frac{\\Delta t}{\\Delta x^2}. \\] <p></p>"},{"location":"theory/backward-euler/#interpretation","title":"Interpretation","text":"<ul> <li>All spatial points at the new time level \\(n+1\\) appear on the left-hand side.   They are unknown and must be solved simultaneously.</li> <li>Values at time level \\(n\\) appear only on the right-hand side and are known data.</li> <li>In 1D, this leads to a tridiagonal linear system at each time step.</li> </ul>"},{"location":"theory/backward-euler/#key-properties","title":"Key properties","text":"<ul> <li>Implicit in time \u2192 requires solving a linear system</li> <li>Unconditionally stable for diffusion problems</li> <li>First-order accurate in time, second-order in space</li> </ul>"},{"location":"theory/backward-euler/#visual-intuition","title":"Visual intuition","text":"<p>A stencil diagram for this scheme can be generated with the package viz helper (see examples notebook <code>backward-euler-stencil.ipynb</code> or <code>permeation.viz.plot_grid_stencil</code> with <code>mode=\"time\"</code>). In the diagram:</p> Color Meaning Node Green Known value (previous time step) \\(u_j^n\\) Yellow Coupled unknowns (same time level) \\(u_{j\\pm1}^{n+1}\\) Red Focal unknown (center) \\(u_j^{n+1}\\) <p>All yellow and red nodes belong to the same solve at time \\(n+1\\), which is the defining feature of the Backward Euler method.</p>"},{"location":"theory/backward-euler/#time-integration","title":"Time integration","text":""},{"location":"theory/backward-euler/#backward-euler","title":"Backward Euler","text":"<ul> <li>Type: fully implicit, first-order in time</li> <li>Used for: time integration of the diffusion equation</li> </ul> <p>The diffusion equation is discretised in time as:</p> \\[ \\frac{u^{n+1} - u^n}{\\Delta t} = D \\frac{\\partial^2 u^{n+1}}{\\partial x^2} \\] <p>This leads to a linear system of the form:</p> \\[ (I - \\Delta t\\,D\\,L)\\,u^{n+1} = u^n \\] <p>where \\(L\\) is the discrete Laplacian operator, and \\(I\\) is identity operatro, see notation</p> <p>References</p> <ul> <li>Backward Euler method</li> <li>Implicit methods</li> </ul>"},{"location":"theory/backward-euler/#spatial-discretisation","title":"Spatial discretisation","text":""},{"location":"theory/backward-euler/#central-finite-differences","title":"Central finite differences","text":"<ul> <li>Grid: uniform, one-dimensional</li> <li>Order: second-order accurate in space</li> <li>Operator: three-point stencil for the second derivative</li> </ul> <p>Used to discretise the Laplacian in the diffusion equation.</p> <p>References</p> <ul> <li>Finite difference method</li> <li>Discrete Laplacian</li> </ul>"},{"location":"theory/backward-euler/#linear-system-solution","title":"Linear system solution","text":""},{"location":"theory/backward-euler/#sparse-tridiagonal-system","title":"Sparse tridiagonal system","text":"<p>Each time step requires solving a sparse tridiagonal linear system resulting from the implicit diffusion operator.</p> <ul> <li>Matrix assembly: <code>scipy.sparse.diags</code></li> <li>Linear solver: <code>scipy.sparse.linalg.spsolve</code></li> </ul> <p>References</p> <ul> <li>SciPy sparse matrices</li> <li>Tridiagonal matrix algorithm</li> </ul>"},{"location":"theory/backward-euler/#boundary-conditions","title":"Boundary conditions","text":""},{"location":"theory/backward-euler/#nonlinear-recombination-boundary-conditions","title":"Nonlinear recombination boundary conditions","text":"<p>At the upstream and downstream boundaries, the flux depends quadratically on the local concentration:</p> \\[ \\Gamma \\propto u^2 \\] <p>This introduces nonlinearity only at the boundaries; the interior diffusion equation remains linear.</p>"},{"location":"theory/backward-euler/#nonlinear-treatment","title":"Nonlinear treatment","text":""},{"location":"theory/backward-euler/#picard-fixed-point-iteration","title":"Picard (fixed-point) iteration","text":"<p>The nonlinear boundary terms are handled using Picard iteration:</p> \\[ u^2 \\;\\approx\\; a \\cdot u \\] <p>where the coefficient \\(a\\) is taken from the previous iterate. The resulting linear system is solved repeatedly until convergence.</p> <p>An explicit predictor is used only to initialise the boundary values before iteration.</p> <p>References</p> <ul> <li>Picard iteration</li> <li>Fixed-point iteration</li> <li>Picard's iteration method</li> </ul>"},{"location":"theory/backward-euler/#notes","title":"Notes","text":"<ul> <li>The scheme is unconditionally stable with respect to the diffusion CFL   condition.</li> <li>Numerical damping of fast transients is expected (typical for Backward Euler).</li> <li>Nonlinearity is confined to the boundary treatment.</li> </ul> <p>Stencil diagrams are generated with <code>permeation.viz.plot_grid_stencil(..., mode=\"time\")</code>; see the examples folder for the Backward Euler stencil notebook.</p>"},{"location":"theory/diffusion/","title":"Permeation equation","text":"<p>The general equation for hydrogen permeation through a membrane (one-dimensional case):</p> \\[ \\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} + f(u) \\] \\[ \\Gamma_{\\mathrm{in}}(t) + D\\frac{\\partial u}{\\partial x}\\bigg|_{x = 0} - k_{u}u^{2}(0,t) = 0 \\] \\[ -D\\frac{\\partial u}{\\partial x}\\bigg|_{x = L} - k_{d}u^{2}(L,t) = 0 \\] <p>Here \\(u\\) is the concentration, \\(t\\) is time, \\(x\\) is the coordinate, \\(D\\) is the diffusion coefficient, \\(k_u\\) and \\(k_d\\) are the hydrogen recombination coefficients on the upstream and downstream sides, and \\(f(u)\\) may represent the contribution of hydrogen traps. The term \\(\\Gamma_{\\mathrm{in}}(t)\\) is the incident atomic hydrogen flux.</p> <p>The matrix in the non-boundary points is the same as in the Crank\u2013Nicolson formulation; the boundary coefficients are determined by the above boundary conditions. At the left boundary:</p> \\[ \\Gamma_{\\mathrm{inc}}^n - k_u U_0^{n2} + D\\frac{U_1^n - U_0^n}{\\Delta x} = 0 \\] <p>At the right boundary:</p> \\[ k_d U_{J-1}^{n2} + D\\frac{U_{J-1}^n - U_{J-2}^n}{\\Delta x} = 0 \\] <p>Solving both quadratic equations for \\(U_0^n\\) and \\(U_{J-1}^n\\) gives the boundary values from the previous time layer:</p> \\[ U_0^{n+1} = -\\frac{D}{2k_u\\Delta x} + \\frac{1}{2} \\sqrt{\\left(\\frac{D}{k_u \\Delta x}\\right)^2 + \\frac{4DU_1^n}{k_u \\Delta x} + \\frac{4\\Gamma_{\\mathrm{inc}}^n}{k_u}} \\] \\[ U_{J-1}^{n+1} = -\\frac{D}{2k_d\\Delta x} + \\frac{1}{2} \\sqrt{\\left(\\frac{D}{k_d \\Delta x}\\right)^2 + \\frac{4DU_{J-2}^n}{k_d \\Delta x}} \\]"},{"location":"theory/finite-methods/","title":"Finite difference methods","text":"<p>This section is adapted from the numerical-mooc notebooks.</p>"},{"location":"theory/finite-methods/#the-cranknicolson-method","title":"The Crank\u2013Nicolson method","text":"<p>The Crank\u2013Nicolson method is a finite difference scheme for the numerical integration of the heat equation and related PDEs. It is often used for reaction\u2013diffusion systems in one space dimension:</p> \\[ \\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} + f(u), \\qquad \\frac{\\partial u}{\\partial x}\\bigg|_{x = 0, L} = 0 \\] <p>Here \\(u\\) is the concentration, \\(x\\) is space, \\(D\\) is the diffusion coefficient, \\(f\\) is the reaction term, and \\(L\\) is the length of the domain. The boundary conditions are Neumann (zero flux at the boundaries).</p>"},{"location":"theory/finite-methods/#grid-and-notation","title":"Grid and notation","text":"<p>Time and space are discretised as:</p> \\[ t_n = n \\Delta t, \\quad n = 0, \\ldots, N-1 \\] \\[ x_j = j \\Delta x, \\quad j = 0, \\ldots, J-1 \\] <p>with \\(\\Delta t = T/N\\) and \\(\\Delta x = L/J\\). We write \\(U_j^n = U(j\\Delta x, n\\Delta t)\\) and define \\(\\sigma = \\frac{D \\Delta t}{2 \\Delta x^2}\\). The Crank\u2013Nicolson scheme for the reaction\u2013diffusion equation is:</p> \\[ -\\sigma U_{j-1}^{n+1} + (1+2\\sigma) U_j^{n+1} -\\sigma U_{j+1}^{n+1} = \\sigma U_{j-1}^n + (1-2\\sigma) U_j^n + \\sigma U_{j+1}^n + \\Delta t f(U_j^n) \\] <p>for \\(j = 1,\\ldots,J-2\\). At the boundaries \\(j=0\\) and \\(j=J-1\\) the values \\(U_{-1}^n\\) and \\(U_J^n\\) are defined by the Neumann conditions (backward difference at \\(j=0\\), forward at \\(j=J-1\\)):</p> \\[ \\frac{U_1^n - U_0^n}{\\Delta x} = 0, \\qquad \\frac{U_J^n - U_{J-1}^n}{\\Delta x} = 0 \\] <p>so \\(U_0^n = U_1^n\\) and \\(U_{J-1}^n = U_J^n\\). In vector form \\(\\mathbf{U}^n = (U_0^n, \\ldots, U_{J-1}^n)^T\\) the system is:</p> \\[ A \\mathbf{U}^{n+1} = B \\mathbf{U}^n + \\mathbf{f}^n \\] <p>and</p> \\[ \\mathbf{U}^{n+1} = A^{-1} \\left( B \\mathbf{U}^n + \\mathbf{f}^n \\right) \\] <p>Matrix \\(A\\) is constant and can be factorised once; \\(B \\mathbf{U}^n + \\mathbf{f}^n\\) is updated each time step.</p>"}]}